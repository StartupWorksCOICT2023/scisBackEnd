generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model School {
  id           Int           @id @default(autoincrement())
  schoolId     String        @unique
  name         String
  address      String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  students     Student[]
  teachers     Teacher[]
  userProfiles UserProfile[]
}

model UserProfile {
  id             Int       @id @default(autoincrement())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  firstName      String
  lastName       String?
  userId         String    @unique
  secondname     String?
  dob            String?
  phone1         String
  phone2         String?
  gender         String?
  religion       String?
  email          String?
  occupation     String?
  address        String?
  district       String?
  region         String?
  country        String?
  profilePicture String?
  isActive       String?
  schoolId       String?
  school         School?   @relation(fields: [schoolId], references: [schoolId])
  student        Student[] @relation("Studentsprofile")
  parent         Parent[]  @relation("parentsprofile")
  teacher        Teacher[] @relation("Teachersprofile")
  user           scisUser? @relation("UserProfileToScisUser", fields: [userId], references: [scisuserid])
}

model scisUser {
  id          Int          @id @default(autoincrement())
  password    String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  scisuserid  String       @unique
  roleId      String?
  parents     Parent[]
  students    Student[]
  teachers    Teacher[]
  tokens      Token[]      @relation("UserTokens")
  userProfile UserProfile? @relation("UserProfileToScisUser")
  roles       Role?        @relation(fields: [roleId], references: [name])
}

model Role {
  id        Int        @id @default(autoincrement())
  name      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  users     scisUser[]
}

model Token {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  token     String   @unique
  expiresAt DateTime
  userId    Int
  user      scisUser @relation("UserTokens", fields: [userId], references: [id])
}

model Teacher {
  id        Int           @id @default(autoincrement())
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  TeacheruserId    String @unique
  schoolId  String
  subjects  Subject[]     @relation("SubjectTeacher")
  school    School        @relation(fields: [schoolId], references: [schoolId])
  user      scisUser?     @relation(fields: [TeacheruserId], references: [scisuserid])
  profile   UserProfile[] @relation("Teachersprofile")
}

model ClassLevel {
  id          Int       @id @default(autoincrement())
  classId     String    @unique
  year        String
  level       String?
  class       String
  combination String?
  stream      String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  students    Student[] @relation("ClassLevelStudents")
  subjects    Subject[] @relation("ClassLevelSubjects")
  tests       Test[]    @relation("ClassLevelTests") // Added this line to establish the one-to-many relationship with Test
}

model Subject {
  id          Int          @id @default(autoincrement())
  subjectId   String       @unique
  name        String
  createdAt   DateTime     @default(now())
  classLevelId String
  TeacherId    String?
  updatedAt   DateTime     @updatedAt
  teacher     Teacher?    @relation("SubjectTeacher", fields: [TeacherId], references: [TeacheruserId])
  tests       Test[]
  classLevels ClassLevel? @relation("ClassLevelSubjects",  fields: [classLevelId], references: [classId])
}

model Test {
  id             Int              @id @default(autoincrement())
  testId         String           @unique
  ExamType       String // ASS1, ASS2, QUIZ1, MIDTERMMARCH, MIDTERMSEPT, ANNUAL, etc.
  ExamClassLevel String?
  TotalMarks     String
  ExamDate       String?
  ExamStartTime  String?
  ExamDuration   String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  subjectId      String
  studentResults StudentResults[]

  subject    Subject     @relation(fields: [subjectId], references: [subjectId])
  classLevel ClassLevel? @relation("ClassLevelTests", fields: [ExamClassLevel], references: [classId])
}

//grades table type i.e necta o-level ,a-level ,primary grades,  that is pulled so that grading can be done 

model grades {
  id         Int      @id @default(autoincrement())
  name       String
  gradeA     String
  gradeBplus String?
  gradeB     String
  gradeC     String
  gradeD     String
  gradeE     String?
  gradeF     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model StudentResults {
  id            Int      @id @default(autoincrement()) //not redundant
  studentId     String //redundant //userid is more important //
  testId        String //redundant
  marksObtained Int
  // grade should we filter them on the front end
  // 
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  student       Student  @relation(fields: [studentId], references: [studentUserId]) //STUDENT ID from userid of scisuser
  test          Test     @relation(fields: [testId], references: [testId]) //find all students tests
}

model Student {
  id               Int              @id @default(autoincrement())
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  studentUserId    String           @unique
  studentsschoolId String
  parents          Parent[]
  school           School           @relation(fields: [studentsschoolId], references: [schoolId])
  user             scisUser?        @relation(fields: [studentUserId], references: [scisuserid])
  studentResults   StudentResults[]
  classLevels      ClassLevel[]     @relation("ClassLevelStudents")
  profile          UserProfile[]    @relation("Studentsprofile")
}

model Parent {
  id           Int           @id @default(autoincrement())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  parentUserId String        @unique
  studentId    String
  student      Student?      @relation(fields: [studentId], references: [studentUserId])
  user         scisUser?     @relation(fields: [parentUserId], references: [scisuserid])
  profile      UserProfile[] @relation("parentsprofile")
}

model Event {
  Id            Int      @id @default(autoincrement())
  Description   String
  StartTime     DateTime
  EndTime       DateTime
  Location      String
  RecurrenceRule String?
  IsAllDay      Boolean
  Subject       String

  // You can add relationships to other models if needed
}
